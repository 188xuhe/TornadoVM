diff --git a/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLCompilationResultBuilder.java b/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLCompilationResultBuilder.java
index 2ac7f64..9db6c05 100644
--- a/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLCompilationResultBuilder.java
+++ b/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLCompilationResultBuilder.java
@@ -37,9 +37,6 @@
 
 import static tornado.common.exceptions.TornadoInternalError.guarantee;
 import static tornado.graal.TornadoLIRGenerator.trace;
-import static tornado.graal.TornadoLIRGenerator.trace;
-import static tornado.graal.TornadoLIRGenerator.trace;
-import static tornado.graal.TornadoLIRGenerator.trace;
 
 public class OCLCompilationResultBuilder extends CompilationResultBuilder {
 
@@ -158,7 +155,7 @@
 
         final int numDominated = dominates.size();
 
-        // System.out.printf("schedule: block=%s, succs=%s, dominates=%s, floating=%s, pdom=%s\n",b.getId(),toString(b.getSuccessors()),toString(dominates),toString(merges),b.getPostdominator());
+        System.out.printf("schedule: block=%s, succs=%s, dominates=%s, floating=%s, pdom=%s\n", b.getId(), toString(b.getSuccessors()), toString(dominates), toString(merges), b.getPostdominator());
         if (b.isLoopEnd()) {
             patchLoopEnd(b);
         }
@@ -180,24 +177,42 @@
 
             // more than one exit means that there are break statements inside
             // the loopbody...
-            Block exit = null;
-            if (loop.getExits().size() > 1) {
-                // multiple exists should converge at a merge node
-                exit = loop.getExits().get(0);
+            Block exit = loop.getExits().get(0);
+//            if (loop.getExits().size() > 1) {
+//                // multiple exists should converge at a merge node
+//                exit = loop.getExits().get(0);
+//
+//                Set<Block> successors = new HashSet<>();
+//                successors.addAll(dominates);
+//                successors.removeAll(loop.getExits());
+//                successors.removeAll(loop.getBlocks());
+//                System.out.printf("exit: block=%s, succ=%d, pred=%d\n", exit, exit.getSuccessorCount(), exit.getPredecessorCount());
+//                System.out.printf("exit: dominates %s\n", toString(dominates));
+//                System.out.printf("exit: loop blocks %s\n", toString(loop.getBlocks()));
+//                if (successors.size() == 1) {
+//                    exit = successors.iterator().next();
+//                }
+//                guarantee(exit.getBeginNode() instanceof AbstractMergeNode,
+//                        "loop exits do not converge: block=%d", b.getId());
+//            } else {
+//                exit = loop.getExits().get(0);
+//            }
+
+            boolean needsMerge = loop.getExits().size() > 1;
+            Block merge = exit;
+            if (needsMerge) {
                 Set<Block> successors = new HashSet<>();
                 successors.addAll(dominates);
                 successors.removeAll(loop.getExits());
                 successors.removeAll(loop.getBlocks());
-                // System.out.printf("exit: block=%s, succ=%d, pred=%d\n",exit,exit.getSuccessorCount(),exit.getPredecessorCount());
-                // System.out.printf("exit: dominates %s\n",toString(dominates));
-                // System.out.printf("exit: loop blocks %s\n",toString(loop.getBlocks()));
+                System.out.printf("merge: block=%s, succ=%d, pred=%d\n", exit, exit.getSuccessorCount(), exit.getPredecessorCount());
+                System.out.printf("merge: dominates %s\n", toString(dominates));
+                System.out.printf("merge: loop blocks %s\n", toString(loop.getBlocks()));
                 if (successors.size() == 1) {
-                    exit = successors.iterator().next();
+                    merge = successors.iterator().next();
                 }
-                guarantee(exit.getBeginNode() instanceof AbstractMergeNode,
-                        "loop exists do not converge: block=%d", b.getId());
-            } else {
-                exit = loop.getExits().get(0);
+                guarantee(merge.getBeginNode() instanceof AbstractMergeNode,
+                        "loop exits do not converge: block=%d", b.getId());
             }
 
             final boolean inverted = (dominates.get(0).equals(exit));
@@ -213,11 +228,14 @@
 
             asm.beginScope();
             traverseCFG(cfg, asm, merges, body);
+            if (needsMerge) {
+                traverseCFG(cfg, asm, merges, exit);
+            }
             asm.endScope();
 
             // System.out.printf("backedge: %s\n",backedge);
-            // System.out.printf("loop exit: exit=%s, exit count=%d\n",exit,b.getLoop().getExits().size());
-            traverseCFG(cfg, asm, merges, exit);
+            System.out.printf("loop exit: exit=%s, merge=%s, exit count=%d\n", exit, merge, b.getLoop().getExits().size());
+            traverseCFG(cfg, asm, merges, merge);
         } else if (isIfBlock(b)) {
             // System.out.printf("branch: succ=%s, doms=%s\n",toString(b.getSuccessors()),toString(dominates));
 
diff --git a/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java b/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java
index 39b82c9..570de6a 100644
--- a/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java
+++ b/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java
@@ -2,6 +2,7 @@
 
 import com.oracle.graal.compiler.common.LIRKind;
 import com.oracle.graal.compiler.common.calc.Condition;
+import com.oracle.graal.compiler.common.cfg.AbstractBlockBase;
 import com.oracle.graal.compiler.common.cfg.BlockMap;
 import com.oracle.graal.compiler.common.type.ObjectStamp;
 import com.oracle.graal.compiler.common.type.Stamp;
@@ -556,26 +557,31 @@
     @Override
     public void visitMerge(final AbstractMergeNode mergeNode) {
         trace("visitMerge: ", mergeNode);
-        // System.out.printf("merge: %s\n",mergeNode);
+        System.out.printf("merge: %s\n", mergeNode);
 
-        boolean loopExitMerge = true;
+        int loopExits = 0;
         for (EndNode end : mergeNode.forwardEnds()) {
-            loopExitMerge &= end.predecessor() instanceof LoopExitNode;
+            if (end.predecessor() instanceof LoopExitNode) {
+                loopExits++;
+            }
         }
 
+        boolean loopExitMerge = loopExits > 0;
+
         for (ValuePhiNode phi : mergeNode.valuePhis()) {
-            // System.out.printf("visitMerge: merge=%s, phi=%s, operand=%s\n",mergeNode,
-            // phi,operandForPhi(phi));
+            System.out.printf("visitMerge: merge=%s, phi=%s, operand=%s\n", mergeNode,
+                    phi, operandForPhi(phi));
             final ValueNode value = phi.singleValue();
             if (value != PhiNode.MULTIPLE_VALUES) {
-                // System.out.printf("emitting: phi=%s, value=%s\n",phi,value);
+                System.out.printf("emitting: phi=%s, value=%s\n", phi, value);
                 AllocatableValue dest = gen.asAllocatable(operandForPhi(phi));
                 Value src = operand(value);
 
                 if (!dest.equals(src)) {
                     append(new OCLLIRStmt.AssignStmt(dest, src));
                 }
-            } else if (loopExitMerge) {
+            } else if (loopExitMerge && loopExits == 1) {
+                System.out.printf("emitting: phi=%s, loop exit\n", phi);
                 AllocatableValue dest = gen.asAllocatable(operandForPhi(phi));
                 Value src = operand(phi.valueAt(1));
 
@@ -719,12 +725,37 @@
     @Override
     public void visitEndNode(final AbstractEndNode end) {
         trace("visitEnd: %s", end);
+        final AbstractMergeNode merge = end.merge();
+
+        for (PhiNode phi : merge.phis()) {
+            System.out.printf("phi: %s, isLoopPhi=%s\n", phi, phi.isLoopPhi());
+            for (int i = 0; i < phi.valueCount(); i++) {
+                System.out.printf("\tvalue %d: %s -> \n", i, phi.valueAt(i), operand(phi.valueAt(i)));
+            }
+            System.out.printf("\tvalue here: %s\n", phi.valueAt(end));
+        }
+
+        for (ValuePhiNode phi : merge.valuePhis()) {
+            System.out.printf("value-phi: %s, isLoopPhi=%s\n", phi, phi.isLoopPhi());
+            for (int i = 0; i < phi.valueCount(); i++) {
+                System.out.printf("\tvalue %d: %s -> \n", i, phi.valueAt(i), operand(phi.valueAt(i)));
+            }
+            System.out.printf("\tvalue here: %s\n", phi.valueAt(end));
+        }
 
         if (end instanceof LoopEndNode) {
             return;
         }
 
-        final AbstractMergeNode merge = end.merge();
+        AbstractBlockBase b = getGen().getCurrentBlock();
+        if (b.getId() == 5) {
+            System.out.println("Block " + b.getId());
+            List<LIRInstruction> insns = getGen().getResult().getLIR().getLIRforBlock(b);
+            for (int i = 0; i < insns.size(); i++) {
+                System.out.printf("\t%3d: %s\n", i, insns.get(i).toString());
+            }
+        }
+
         for (ValuePhiNode phi : merge.valuePhis()) {
             final ValueNode value = phi.valueAt(end);
             if (!phi.isLoopPhi()
@@ -736,6 +767,15 @@
                 append(new OCLLIRStmt.AssignStmt(result, operand(value)));
             }
         }
+
+//        AbstractBlockBase b = getGen().getCurrentBlock();
+        if (b.getId() == 5) {
+            System.out.println("Block " + b.getId());
+            List<LIRInstruction> insns = getGen().getResult().getLIR().getLIRforBlock(b);
+            for (int i = 0; i < insns.size(); i++) {
+                System.out.printf("\t%3d: %s\n", i, insns.get(i).toString());
+            }
+        }
     }
 
     public Value operandForPhi(ValuePhiNode phi) {
