diff --git a/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java b/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java
index 39b82c9..570de6a 100644
--- a/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java
+++ b/drivers/opencl/src/main/java/tornado/drivers/opencl/graal/compiler/OCLNodeLIRBuilder.java
@@ -2,6 +2,7 @@
 
 import com.oracle.graal.compiler.common.LIRKind;
 import com.oracle.graal.compiler.common.calc.Condition;
+import com.oracle.graal.compiler.common.cfg.AbstractBlockBase;
 import com.oracle.graal.compiler.common.cfg.BlockMap;
 import com.oracle.graal.compiler.common.type.ObjectStamp;
 import com.oracle.graal.compiler.common.type.Stamp;
@@ -556,26 +557,31 @@
     @Override
     public void visitMerge(final AbstractMergeNode mergeNode) {
         trace("visitMerge: ", mergeNode);
-        // System.out.printf("merge: %s\n",mergeNode);
+        System.out.printf("merge: %s\n", mergeNode);
 
-        boolean loopExitMerge = true;
+        int loopExits = 0;
         for (EndNode end : mergeNode.forwardEnds()) {
-            loopExitMerge &= end.predecessor() instanceof LoopExitNode;
+            if (end.predecessor() instanceof LoopExitNode) {
+                loopExits++;
+            }
         }
 
+        boolean loopExitMerge = loopExits > 0;
+
         for (ValuePhiNode phi : mergeNode.valuePhis()) {
-            // System.out.printf("visitMerge: merge=%s, phi=%s, operand=%s\n",mergeNode,
-            // phi,operandForPhi(phi));
+            System.out.printf("visitMerge: merge=%s, phi=%s, operand=%s\n", mergeNode,
+                    phi, operandForPhi(phi));
             final ValueNode value = phi.singleValue();
             if (value != PhiNode.MULTIPLE_VALUES) {
-                // System.out.printf("emitting: phi=%s, value=%s\n",phi,value);
+                System.out.printf("emitting: phi=%s, value=%s\n", phi, value);
                 AllocatableValue dest = gen.asAllocatable(operandForPhi(phi));
                 Value src = operand(value);
 
                 if (!dest.equals(src)) {
                     append(new OCLLIRStmt.AssignStmt(dest, src));
                 }
-            } else if (loopExitMerge) {
+            } else if (loopExitMerge && loopExits == 1) {
+                System.out.printf("emitting: phi=%s, loop exit\n", phi);
                 AllocatableValue dest = gen.asAllocatable(operandForPhi(phi));
                 Value src = operand(phi.valueAt(1));
 
@@ -719,12 +725,37 @@
     @Override
     public void visitEndNode(final AbstractEndNode end) {
         trace("visitEnd: %s", end);
+        final AbstractMergeNode merge = end.merge();
+
+        for (PhiNode phi : merge.phis()) {
+            System.out.printf("phi: %s, isLoopPhi=%s\n", phi, phi.isLoopPhi());
+            for (int i = 0; i < phi.valueCount(); i++) {
+                System.out.printf("\tvalue %d: %s -> \n", i, phi.valueAt(i), operand(phi.valueAt(i)));
+            }
+            System.out.printf("\tvalue here: %s\n", phi.valueAt(end));
+        }
+
+        for (ValuePhiNode phi : merge.valuePhis()) {
+            System.out.printf("value-phi: %s, isLoopPhi=%s\n", phi, phi.isLoopPhi());
+            for (int i = 0; i < phi.valueCount(); i++) {
+                System.out.printf("\tvalue %d: %s -> \n", i, phi.valueAt(i), operand(phi.valueAt(i)));
+            }
+            System.out.printf("\tvalue here: %s\n", phi.valueAt(end));
+        }
 
         if (end instanceof LoopEndNode) {
             return;
         }
 
-        final AbstractMergeNode merge = end.merge();
+        AbstractBlockBase b = getGen().getCurrentBlock();
+        if (b.getId() == 5) {
+            System.out.println("Block " + b.getId());
+            List<LIRInstruction> insns = getGen().getResult().getLIR().getLIRforBlock(b);
+            for (int i = 0; i < insns.size(); i++) {
+                System.out.printf("\t%3d: %s\n", i, insns.get(i).toString());
+            }
+        }
+
         for (ValuePhiNode phi : merge.valuePhis()) {
             final ValueNode value = phi.valueAt(end);
             if (!phi.isLoopPhi()
@@ -736,6 +767,15 @@
                 append(new OCLLIRStmt.AssignStmt(result, operand(value)));
             }
         }
+
+//        AbstractBlockBase b = getGen().getCurrentBlock();
+        if (b.getId() == 5) {
+            System.out.println("Block " + b.getId());
+            List<LIRInstruction> insns = getGen().getResult().getLIR().getLIRforBlock(b);
+            for (int i = 0; i < insns.size(); i++) {
+                System.out.printf("\t%3d: %s\n", i, insns.get(i).toString());
+            }
+        }
     }
 
     public Value operandForPhi(ValuePhiNode phi) {
